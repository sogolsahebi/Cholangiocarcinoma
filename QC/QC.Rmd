---
title: "Analysis of SE_CCA Summarized Experiment."
author: "Nasim Bondar Sahebi"
date: "2023-12-20"
output: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


# # Load libraries.

```{r libraries}

library(SummarizedExperiment)
library(dplyr)
library("ggpubr")



#library(ggplot2)
#library(dplyr)
#library(limma)
#library(EnhancedVolcano)
#library(DT)
#library(RColorBrewer)
#library(readr)

```


# Data Loading and Preparation

## Load Gene Summarized Experiment Data

#### Data Overview

  - **Paper name **:  Genomic characterization of cholangiocarcinoma with autoimmune etiologies
  - **Patient samples **: 33 
  - **RNA sequencing (RNA-seq)**: 33 patients
  - **Non-autoimmune **:  25 patients
  - **Non-autoimmune **:  15 patients
  

Load the Summarized Experiment .rds file (SE_CCA.rds), extract clinical and expression data (TPM), along with annotations, and prepare the gene expression data for analysis.

```{r load-data}

# Load your SE result and extract clinical data , expression data and annotation

# Load SE obj
se <- readRDS("~/BHK lab/kevin Project/Cholangiocarcinoma/data/SE_CCA.rds")

# Extract Clinical data 
clin <- data.frame(colData(se))

# Extract the expression data
expr_tpm <- assays(se)[["expr_tpm"]]

# Extract the annotation
annot <- data.frame(rowData(se))

# Display first few rows of the dataset
data.frame(expr_tpm[1:10, 1:8])

```

# Data Preparation 

Preparing expression data (RNA-seq) for analysis:

1. **Restrict expression data to protein-coding genes.**
2. **Remove low/zero expression genes**"


```{r  Data Preparation  }

# Step 1: Restrict to Protein-Coding Genes.
annot_proteincoding <- annot[annot$gene_type == "protein_coding",] # 19205 protein coding genes.
expr_tpm <- expr_tpm[rownames(expr_tpm) %in% rownames(annot_proteincoding),]


# Step 2: Remove genes with low/zero expression in over 50% of samples
r <- as.numeric(apply(expr_tpm, 1, function(i) sum(round(i, 6) == round(log2(1), 6))))
remove <- which(r > dim(expr_tpm)[2] * 0.50)
expr_tpm <- expr_tpm[-remove, ]  # Update expr_tpm with filtered genes- dimension 16256 x 33

# Transpose expr_tpm 
expr_tm <- t(expr_tpm)


data.frame(expr_tpm[1:10, 1:8])
```

# Descriptive analysis


- **Objective**: Evaluate differences in clinicodemographic and staging variables between autoimmune and non-autoimmune groups.

- **Methods**:
  - For continuous variables (e.g., age): Analyze using median and IQR. Apply the Wilcoxon test to assess associations.
  
  - For discrete/categorical variables (e.g., sex, Location, stage): Analyze using frequency and percentage. Use Chi-squared or Fisher's exact test for association.


```{r descriptive-analysis, echo=TRUE}


# Set 'y' and 'n' to 'Autoimmune' and 'Non-Autoimmune' within the dataframe
clin$psc_ibd[clin$psc_ibd == 'y'] <- 'Autoimmune'
clin$psc_ibd[clin$psc_ibd == 'n'] <- 'Non-Autoimmune'

# 1. Age

# Summarize age statistics (count,Mean(SD), Median(IQR), Min,Max) for each psc_ibd group.
summary_stats <- summarise(
  group_by(clin, psc_ibd),
  count = n(),
  Mean_SD = sprintf("%.2f(%.2f)", mean(age, na.rm = TRUE), sd(age, na.rm = TRUE)),
  Median_IQR = sprintf("%.2f(%.2f)", median(age, na.rm = TRUE), IQR(age, na.rm = TRUE)),
  Min_Max = sprintf("%.2f,%.2f", min(age, na.rm = TRUE), max(age, na.rm = TRUE))
)

# Store statistics for Auto and Non-Auto for later use
auto_count <- summary_stats$count[summary_stats$psc_ibd == "Autoimmune"]
non_auto_count <- summary_stats$count[summary_stats$psc_ibd == "Non-Autoimmune"]

# Visualize your data.

# Plotting boxplot for age distributions
ggplot(clin, aes(x = psc_ibd, y = age, color = psc_ibd)) +
  geom_boxplot() +
  scale_color_manual(values = c("Autoimmune" = "#00AFBB", "Non-Autoimmune" = "#E7B800")) +
  labs(y = "Age", x = "PSC-IBD")

# Perform two-sample Wilcoxon test
res <- wilcox.test(age ~ psc_ibd, data = clin, exact = FALSE)
p_value_age <- res$p.value

# 2. Sex

# Perform Fisher's Exact Test for 'sex' and 'psc_ibd'
contingency_sex <- table(clin$sex, clin$psc_ibd)
p_value_sex <- fisher.test(contingency_sex)$p.value

# Calculate and format percentages for Sex
sex_stats <- apply(contingency_sex, 2, function(x) sprintf("%d (%.1f%%)", x, 100 * x / sum(x)))

# Perform Fisher's Exact Test for 'location' and 'psc_ibd'
contingency_loc <- table(clin$location, clin$psc_ibd)
p_value_loc <- fisher.test(contingency_loc)$p.value

# Calculate and format percentages for Location
location_stats <- apply(contingency_loc, 2, function(x) sprintf("%d (%.1f%%)", x, 100 * x / sum(x)))

# Perform Fisher's Exact Test for 'stage' and 'psc_ibd'
clin$stage <- with(clin, ifelse(stage %in% c("IIIA", "IIIB", "IIIC"), "III",
                                ifelse(stage %in% c("IVA", "IVB"), "IV", stage)))

contingency_stage <- table(clin$stage, clin$psc_ibd)
p_value_stage <- fisher.test(contingency_stage)$p.value

# Calculate and format percentages for Stage
stage_stats <- apply(contingency_stage, 2, function(x) sprintf("%d (%.1f%%)", x, 100 * x / sum(x)))

# Combine all statistics into a data frame for the table
result <- data.frame(
  Characteristics = c("Age", "Mean (SD)", "Median (IQR)", "Min, Max", "", "Sex", "F", "M", "", "Location", "dCCA", "GBC", "iCCA", "pCCA", "", "Stage", "II", "III", "IV"),
  `Autoimmune (n=14)` = c("", summary_stats$Mean_SD[1], summary_stats$Median_IQR[1], summary_stats$Min_Max[1], "", "", sex_stats[1, 1], sex_stats[2, 1], "", "", location_stats[1, 1], location_stats[2, 1], location_stats[3, 1], location_stats[4, 1], "", "", stage_stats[1, 1], stage_stats[2, 1], stage_stats[3, 1]),
  `Non-Autoimmune (n=19)` = c("", summary_stats$Mean_SD[2], summary_stats$Median_IQR[2], summary_stats$Min_Max[2], "", "", sex_stats[1, 2], sex_stats[2, 2], "", "", location_stats[1, 2], location_stats[2, 2], location_stats[3, 2], location_stats[4, 2], "", "", stage_stats[1, 2], stage_stats[2, 2], stage_stats[3, 2]),
  `P value` = c(p_value_age, "", "", "", "", p_value_sex, "", "", "", p_value_loc, "", "", "", "", "", p_value_stage, "", "", "")
)

# Print the table


# Render the data frame using kable
table_html <- kable(
  result, 
  format = "html", 
  caption = "Table 1: Baseline clinicodemographic and staging (AJCC 8th) characteristics", 
  escape = FALSE,
  table.attr = 'style="width:100%; overflow-x:scroll; overflow-y:scroll; max-height:400px;"'
)

table_html




```

















### Clinical Data Processing

- Subseting clinical data

```{r load-clinical-data}
# Subsetting 'clin' data frame to include only 'patientid' and 'Institution' columns

clin_subset <- clin[, c("patientid", "Institution")]
clin_subsetresponse <-clin[, c("patientid", "response")]

```

### Merge PCA and Clinical Data 

```{r merge-data}
# Merge PCA results with clinical data
pcx <- data.frame(pc$x)
pcx$patientid <- rownames(pcx)
pcx$patientid <- gsub("\\_", "-", pcx$patientid)

pcx_merge <- merge(pcx, clin_subset, by="patientid")
rownames(pcx_merge) <- pcx_merge[,1]
pcx_merge <- pcx_merge[,-1] # institution column is added

```


# Visualization

### Bar Plot

- Create a bar plot to visualize variance by each principal component.

The bar plot displays PC1 as the longest, explaining the most variance, while subsequent bars (PC2, PC3, etc.) become progressively shorter, indicating diminishing variance. 


```{r scree-plot}
#To find the largest PC of data

barplot(var_res, main="Bar Plot", xlab="Principal Component", ylab="Percentage of Variance ", col="skyblue")
```

### 1. PCA Results Plot


PCA on gene expression data, shows that the 'Institution' factor has no significant effect on gene expression data sampling.
(no Batch effect has been detected)


```{r pca-results-plot}
# Create labels for the plot
xlab_text <- paste("PC1 (", var_res[1], "%)", sep = "")
ylab_text <- paste("PC2 (", var_res[2], "%)", sep = "")

# Plot PCA results
ggplot(pcx_merge, aes(PC1, PC2, color = Institution)) +
  theme_bw() +
  geom_point() +
  labs(x = xlab_text, y = ylab_text)

```

#### 2.Limma approach  

- Used to find the differentially expressed genes between responders and non-responders

```{r diff expression, include=TRUE, result = TRUE}

# Remove rows with missing values in response and expression data
na_response <- is.na(clin$response)

# Create filtered response data by excluding rows with response missing values
filtered_response <- clin$response[!na_response] 

# Access the expression data and exclude rows with missing response values
filtered_expression <- expr[, !na_response] #27 rows removed due to missing response values
 

# Create a design matrix using the filtered response data
design <- model.matrix(~ filtered_response)

# Fit a linear model using the filtered expression data and the design matrix
fit <- lmFit(filtered_expression, design)

# Perform eBayes analysis
fit <- eBayes(fit)

# To display the results in a table format, you can use 'datatable'
datatable(topTable(fit))

```

### 3. Volcano plot Prepration.

- Preparing Data for volcano Plot 

- Convert fit to Data frame and add column gene_name symbol

```{r prepare volcano, include=TRUE, result = TRUE}

# Retrieve all results from the analysis
volcano_data <- topTable(fit, number=Inf) 

# Convert the result to a data frame
df <- as.data.frame(volcano_data)

# Subset 'gene_id' and 'gene_name' from the gene data
subset_annot <- annot_proteincoding[, c("gene_id", "gene_name")]

# Add a 'gene_id' column to the volcano_data
volcano_data$gene_id <- rownames(volcano_data)

# Merge 'volcano_data' and 'annot_proteincoding' by 'gene_id'
merge_result <- merge(volcano_data, subset_annot, by= "gene_id")

# Display the merged result in a table format
datatable(merge_result)


```

#### Volcano Plot based on P value 

```{r volcan plot, include=TRUE, result = TRUE}

EnhancedVolcano(merge_result,
    lab = merge_result$gene_name,
    x = 'logFC',
    y = 'P.Value')

```

#### Volcano Plot based on FDR.

```{r volcanplot2, include=TRUE, result = TRUE}



EnhancedVolcano(merge_result,
    lab = merge_result$gene_name,
    x = 'logFC',
    y = 'adj.P.Val')

```

### 4. Figure 1(a) of paper

- First 1.(a)_RNA cohort in different institutions.

```{r piechart , include=TRUE, result = TRUE}


clin <- data.frame(colData(mae))
clin_subset <-clin[,c("Institution","rna")]


# Counting the occurrences of each institution
institution_counts <- table(clin_subset$Institution)

# Creating the pie chart
pie_chart <- ggplot(clin_subset, aes(x = "", fill = factor(Institution))) +
  geom_bar(width = 1, stat = "count") +
  coord_polar("y", start = 0) +
  theme_void() +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9",
                               "#009E73", "#F0E442", "#0072B2",
                               "#D55E00", "#CC79A7", "#999999",
                               "#999999", "#999999", "#999999",
                               "#999999", "#999999", "#999999"))

# Printing the pie chart
print(pie_chart)

```

### 5. Figure 1(b) of paper


Figure 1(b):BOR/recist by PDL1 TPS category.


```{r bar plot, include=TRUE, result = TRUE}


# Select only the necessary columns
clin <- clin[, c("PDL1_TPS_Description", "recist", "PDL1_TPS")]

# Convert NA values to a specific level
clin$PDL1_TPS_Description <- forcats::fct_explicit_na(clin$PDL1_TPS_Description, na_level = "Unknown")
clin$PDL1_TPS_Description <- factor(clin$PDL1_TPS_Description, levels = c("<1%", "1-49%", ">50%", "Unknown"))

clin$recist <- forcats::fct_explicit_na(clin$recist, na_level = "NE")

# Count the occurrences of combinations of 'PDL1_TPS_Description' and 'recist'
# Note: Do not quote the column names
counted_data <- dplyr::count(clin, PDL1_TPS_Description, recist)

# Group by 'PDL1_TPS_Description' and calculate frequencies
grouped_data <- group_by(counted_data, PDL1_TPS_Description)
data_summary <- mutate(grouped_data, freq = n / sum(n))

# Plotting
ggplot(data_summary, aes(x = PDL1_TPS_Description, y = freq, fill = recist)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "PDL1 TPS", y = "BOR Proportion", fill = "RECIST Category") +
  geom_text(aes(label = scales::percent(freq)), position = position_stack(vjust = 0.5)) +
  theme_minimal()


```